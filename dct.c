#include <assert.h>
#include "interpolate.h"

/* The code in this file is a naive implementation of a type-II DCT and I-DCT */
/* It is very inefficient O(N^2) - really only good for illustrating what the
   DCT calculates.  For a higher performance implementation, you want
   a Fast Cosine Transform */

/* globals used by the DCT code - they're set by calling init_dct */
/* scale and scale0 are normalization coefficients. */
static double scale0, scale;

/* initialize the state - N_init is the number of samples you want to perform the DCT on */
void init_dct(int N) {
  scale0 = sqrt(1.0/N);
  scale = sqrt(2.0/N);
}

/* Perform the DCT of the input data */
/* input is an array of N int16_t's (16-bit integers) */
/* output is an array of N signed ints (32-bit integers) to avoid any risk of overflow */
/* N is the number of samples to compute the DCT over, and also the number of DCT coefficients returned */
int *dct(int16_t *idata, int N)
{
  int* odata = malloc(N*sizeof(int)); 
  double out_val;
  int n, k;
  init_dct(N);
  for (k = 0; k < N; k++) {
    out_val = 0;
    for (n = 0; n < N; n++) {
      out_val += idata[n]*cos( (M_PI/N) * k * (n + 0.5));
    }
    if (k==0)
      out_val *= scale0;
    else
      out_val *= scale;
    odata[k] = (int)out_val;
  }
  return odata;
}

/* Perform the IDCT of the input data */
/* input is an array of N signed ints (32-bit integers), as generated by dct() */
/* output is an array of N int16_t's (16-bit integers) */
/* N is the number of DCT coeffients to compute the iDCT over, and also the number of DCT coefficients returned */
int16_t *idct(int *idata, int N)
{
  int16_t* odata = malloc(N*sizeof(int16_t)); 
  double out_val;
  int n, k;
  init_dct(N);
  for (k = 0; k < N; k++) {
    out_val = idata[0]/2.0;
    for (n = 1; n < N; n++) {
      out_val += idata[n]*cos( (M_PI/N) * n * (k + 0.5));
    }
    if (k==0)
      out_val *= scale0;
    else
      out_val *= scale;
    odata[k] = (int16_t)out_val;
  }
  return odata;
}
